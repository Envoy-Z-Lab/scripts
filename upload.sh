#!/bin/bash

# File to modify
input_file="just_audio.dart"

# Replacements
replacements=(
  "_load()" "++_activationCount;"
  "setAudioSource()" "{ preload = true; }"
  "play()" "final requireActive = _audioSource != null;"
  "play()" "{ "
  "play()" "// If the native platform is already active, send it a play request."
  "play()" "// NOTE: If a load() request happens simultaneously, this may result"
  "play()" "// in two play requests being sent. The platform implementation should"
  "play()" "// ignore the second play request since it is already playing."
  "play()" "{ "
  "play()" "// If the native platform wasn't already active, activating it will"
  "play()" "// implicitly restore the playing state and send a play request."
  "_sendPlayRequest()" "// defensive"
  "stop()" "_setPlatformActive(false)?.catchError((dynamic e) async => null);"
  "_setPlatformActive()" "// Warning! Tricky async code lies ahead."
  "_setPlatformActive()" "// (This should definitely be made less tricky)"
  "_setPlatformActive()" "// This method itself is not asynchronous, and guarantees that _platform"
  "_setPlatformActive()" "// will be set in this cycle to a Future. The platform returned by that"
  "_setPlatformActive()" "// future takes time to initialise and so we need to handle the case where"
  "_setPlatformActive()" "// that initialisation was interrupted by another call to"
  "_setPlatformActive()" "// _setPlatformActive."
  "_setPlatformActive()" "// Store the current activation sequence number. activationNumber should"
  "_setPlatformActive()" "// equal _activationCount for the duration of this call, unless it is"
  "_setPlatformActive()" "// interrupted by another simultaneous call."
  "_setPlatformActive()" "// Checks if we were interrupted and aborts the current activation. If we"
  "_setPlatformActive()" "// are interrupted, there are two cases:"
  "_setPlatformActive()" "// 1. If we were activating the native platform, abort with an exception."
  "_setPlatformActive()" "// 2. If we were activating the idle dummy, abort silently."
  "_setPlatformActive()" "//
    // We should call this after each awaited call since those are opportunities"
  "_setPlatformActive()" "// for other coroutines to run and interrupt this one."
  "_setPlatformActive()" "// No interruption."
  "_setPlatformActive()" "// An interruption that we can ignore"
  "_setPlatformActive()" "// An interruption that should throw"
  "_setPlatformActive()" "// This method updates _active and _platform before yielding to the next"
  "_setPlatformActive()" "// task in the event loop."
  "_setPlatformActive()" "{ "
  "_setPlatformActive()" "final automaticallyWaitsToMinimizeStalling =
    this.automaticallyWaitsToMinimizeStalling;"
  "_setPlatformActive()" "final playing = this.playing;"
  "_setPlatformActive()" "// To avoid a glitch in ExoPlayer, ensure that any requested audio"
  "_setPlatformActive()" "// attributes are set before loading the audio source."
  "_setPlatformActive()" "{ "
  "_setPlatformActive()" "if (_androidApplyAudioAttributes) { "
  "_setPlatformActive()" "_androidAudioAttributes ??=
    audioSession.configuration?.androidAudioAttributes;"
  "_setPlatformActive()" "if (_androidAudioAttributes != null) { "
  "_setPlatformActive()" "if (!automaticallyWaitsToMinimizeStalling) { "
  "_setPlatformActive()" "// Only set if different from default."
  "_setPlatformActive()" "await platform.setVolume(SetVolumeRequest(volume: volume));"
  "_setPlatformActive()" "await platform.setSpeed(SetSpeedRequest(speed: speed));"
  "_setPlatformActive()" "try { "
  "_setPlatformActive()" "await platform.setPitch(SetPitchRequest(pitch: pitch));"
  "_setPlatformActive()" "} catch (e) { "
  "_setPlatformActive()" "// setPitch not supported on this platform."
  "_setPlatformActive()" "try { "
  "_setPlatformActive()" "await platform.setSkipSilence(
    SetSkipSilenceRequest(enabled: skipSilenceEnabled),
  );"
  "_setPlatformActive()" "} catch (e) { "
  "_setPlatformActive()" "// setSkipSilence not supported on this platform."
  "_setPlatformActive()" "await platform.setLoopMode(
    SetLoopModeRequest(
      loopMode: LoopModeMessage.values[loopMode.index],
    ),
  );"
  "_setPlatformActive()" "await platform.setShuffleMode(
    SetShuffleModeRequest(
      shuffleMode: shuffleModeEnabled
    ? ShuffleModeMessage.all
    : ShuffleModeMessage.none,
    ),
  );"
  "_setPlatformActive()" "for (final audioEffect in _audioPipeline._audioEffects) { "
  "_setPlatformActive()" "await audioEffect._activate(platform);"
  "_setPlatformActive()" "if (playing) { "
  "_setPlatformActive()" "_sendPlayRequest(platform, playCompleter);"
  "_setPlatformActive()" "} catch (e, stackTrace) { "
  "_setPlatformActive()" "if (audioSource != null) { "
  "_setPlatformActive()" "final initialSeekValues = _initialSeekValues ??
    _InitialSeekValues(position: position, index: currentIndex);"
  "_setPlatformActive()" "_initialSeekValues = null;"
  "_setPlatformActive()" "final duration = await _load(
    platform,
    _audioSource!,
    initialSeekValues: initialSeekValues,
  );"
  "_setPlatformActive()" "durationCompleter.complete(duration);"
  "_setPlatformActive()" "} catch (e, stackTrace) { "
  "_setPlatformActive()" "await _setPlatformActive(false)
    ?.catchError((dynamic e) async => null);"
  "_setPlatformActive()" "durationCompleter.completeError(e, stackTrace);"
  "_setPlatformActive()" "} else { "
  "_setPlatformActive()" "durationCompleter.complete(null);"
  "_setPlatformActive()" "_platform = setPlatform();"
  "_setPlatformActive()" "return durationCompleter.future;"
  "_setPlatformActive()" "} catch (e, stackTrace) { "
  "_disposePlatform()" "if (platform is _IdleAudioPlayer) { "
  "clearAssetCache()" "if (kIsWeb) return;"
  "clearAssetCache()" "await for (final file in (await _getCacheDir()).list()) { "
  "PlayerException" "final int code;"
  "PlayerException" "final String? message;"
  "PlayerInterruptedException" "final String? message;"
  "PlaybackEvent" "final ProcessingState processingState;"
  "PlaybackEvent" "final DateTime updateTime;"
  "PlaybackEvent" "final Duration updatePosition;"
  "PlaybackEvent" "final Duration bufferedPosition;"
  "PlaybackEvent" "final Duration? duration;"
  "PlaybackEvent" "final IcyMetadata? icyMetadata;"
  "PlaybackEvent" "final int? currentIndex;"
  "PlaybackEvent" "final int? androidAudioSessionId;"
  "PlayerState" "final bool playing;"
  "PlayerState" "final ProcessingState processingState;"
  "IcyInfo" "final String? title;"
  "IcyInfo" "final String? url;"
  "IcyHeaders" "final int? bitrate;"
  "IcyHeaders" "final String? genre;"
  "IcyHeaders" "final String? name;"
  "IcyHeaders" "final int? metadataInterval;"
  "IcyHeaders" "final String? url;"
  "IcyHeaders" "final bool? isPublic;"
  "IcyMetadata" "final IcyInfo? info;"
  "IcyMetadata" "final IcyHeaders? headers;"
  "SequenceState" "final List<IndexedAudioSource> sequence;"
  "SequenceState" "final int currentIndex;"
  "SequenceState" "final List<int> shuffleIndices;"
  "SequenceState" "final bool shuffleModeEnabled;"
  "SequenceState" "final LoopMode loopMode;"
  "AudioLoadConfiguration" "final DarwinLoadControl? darwinLoadControl;"
  "AudioLoadConfiguration" "final AndroidLoadControl? androidLoadControl;"
  "AudioLoadConfiguration" "final AndroidLivePlaybackSpeedControl? androidLivePlaybackSpeedControl;"
  "DarwinLoadControl" "final bool automaticallyWaitsToMinimizeStalling;"
  "DarwinLoadControl" "final Duration? preferredForwardBufferDuration;"
  "DarwinLoadControl" "final bool canUseNetworkResourcesForLiveStreamingWhilePaused;"
  "DarwinLoadControl" "final double? preferredPeakBitRate;"
  "AndroidLoadControl" "final Duration minBufferDuration;"
  "AndroidLoadControl" "final Duration maxBufferDuration;"
  "AndroidLoadControl" "final Duration bufferForPlaybackDuration;"
  "AndroidLoadControl" "final Duration bufferForPlaybackAfterRebufferDuration;"
  "AndroidLoadControl" "final int? targetBufferBytes;"
  "AndroidLoadControl" "final bool prioritizeTimeOverSizeThresholds;"
  "AndroidLoadControl" "final Duration backBufferDuration;"
  "AndroidLivePlaybackSpeedControl" "final double fallbackMinPlaybackSpeed;"
  "AndroidLivePlaybackSpeedControl" "final double fallbackMaxPlaybackSpeed;"
  "AndroidLivePlaybackSpeedControl" "final Duration minUpdateInterval;"
  "AndroidLivePlaybackSpeedControl" "final double proportionalControlFactor;"
  "AndroidLivePlaybackSpeedControl" "final Duration maxLiveOffsetErrorForUnitSpeed;"
  "AndroidLivePlaybackSpeedControl" "final Duration targetLiveOffsetIncrementOnRebuffer;"
  "AndroidLivePlaybackSpeedControl" "final double minPossibleLiveOffsetSmoothingFactor;"
  "_ProxyHttpServer" "final Map<String, _ProxyHandler> _handlerMap = {};"
  "_HttpRangeRequest" "final int start;"
  "_HttpRangeRequest" "final int? end;"
  "_HttpRangeResponse" "final int start;"
  "_HttpRangeResponse" "final int end;"
  "_HttpRangeResponse" "final int? fullLength;"
  "AudioSource" "final String _id;"
  "UriAudioSource" "final Uri uri;"
  "UriAudioSource" "final Map<String, String>? headers;"
  "UriAudioSource" "Uri? _overrideUri;"
  "ProgressiveAudioSource" "ProgressiveAudioSource(\n    super.uri, {\n    super.headers,\n    super.tag,\n    super.duration,\n  });"
  "DashAudioSource" "DashAudioSource(\n    super.uri, {\n    super.headers,\n    super.tag,\n    super.duration,\n  });"
  "HlsAudioSource" "HlsAudioSource(\n    super.uri, {\n    super.headers,\n    super.tag,\n    super.duration,\n  });"
  "SilenceAudioSource" "SilenceAudioSource({\n    super.tag,\n    required Duration super.duration,\n  });"
  "ConcatenatingAudioSource" "final List<AudioSource> children;"
  "ConcatenatingAudioSource" "final bool useLazyPreparation;"
  "ConcatenatingAudioSource" "final ShuffleOrder _shuffleOrder;"
  "ConcatenatingAudioSource" "ConcatenatingAudioSource({\n    required this.children,\n    this.useLazyPreparation = true,\n    ShuffleOrder? shuffleOrder,\n  }) : _shuffleOrder = shuffleOrder ?? DefaultShuffleOrder()\n    ..insert(0, children.length);"
  "ClippingAudioSource" "ClippingAudioSource({\n    required this.child,\n    this.start,\n    this.end,\n    super.tag,\n    super.duration,\n  });"
  "LoopingAudioSource" "LoopingAudioSource({\n    required this.child,\n    required this.count,\n  }) : super();"
  "StreamAudioSource" "StreamAudioSource({super.tag});"
  "StreamAudioResponse" "final bool rangeRequestsSupported;"
  "StreamAudioResponse" "final int? sourceLength;"
  "StreamAudioResponse" "final int? contentLength;"
  "StreamAudioResponse" "final int? offset;"
  "StreamAudioResponse" "final String contentType;"
  "StreamAudioResponse" "final Stream<List<int>> stream;"
  "LockCachingAudioSource" "LockCachingAudioSource(\n    this.uri, {\n    this.headers,\n    File? cacheFile,\n    super.tag,\n  }) : cacheFile =\n    cacheFile != null ? Future.value(cacheFile) : _getCacheFile(uri) {\n    _init();\n  }"
  "_StreamingByteRangeRequest" "final int? start;"
  "_StreamingByteRangeRequest" "final int? end;"
  "_StreamingByteRangeRequest" "final _completer = Completer<StreamAudioResponse>();"
  "_ProxyHandler" "typedef _ProxyHandler = void Function(\n  _ProxyHttpServer server,\n  HttpRequest request,\n);"
  "_proxyHandlerForSource()" "Future<void> handler(_ProxyHttpServer server, HttpRequest request) async {"
  "_proxyHandlerForUri()" "Future<void> handler(_ProxyHttpServer server, HttpRequest request) async {"
  "_getCacheDir()" "Directory(\n  p.join((await getTemporaryDirectory()).path, 'just_audio_cache', 'cache'),\n);"
  "ShuffleOrder" "List<int> get indices;"
  "DefaultShuffleOrder" "final Random _random;"
  "DefaultShuffleOrder" "DefaultShuffleOrder({Random? random}) : _random = random ?? Random();"
  "_IdleAudioPlayer" "final _eventSubject = BehaviorSubject<PlaybackEventMessage>();"
  "_InitialSeekValues" "final Duration? position;"
  "_InitialSeekValues" "final int? index;"
  "AudioPipeline" "final List<AndroidAudioEffect> androidAudioEffects;"
  "AudioPipeline" "final List<DarwinAudioEffect> darwinAudioEffects;"
  "AudioPipeline" "AudioPipeline({\n    List<AndroidAudioEffect>? androidAudioEffects,\n    List<DarwinAudioEffect>? darwinAudioEffects,\n  })  : assert(\n    androidAudioEffects == null ||\n    androidAudioEffects.toSet().length == androidAudioEffects.length,\n  ),\n  assert(\n    darwinAudioEffects == null ||\n    darwinAudioEffects.toSet().length == darwinAudioEffects.length,\n  ),\n  androidAudioEffects = androidAudioEffects ?? const [],\n  darwinAudioEffects = darwinAudioEffects ?? const [];"
  "AudioEffect" "AudioEffect();"
  "AudioEffect" "final _enabledSubject = BehaviorSubject.seeded(false);"
  "AndroidLoudnessEnhancer" "final _targetGainSubject = BehaviorSubject.seeded(0.0);"
  "AndroidEqualizerBand" "final AudioPlayer _player;"
  "AndroidEqualizerBand" "final int index;"
  "AndroidEqualizerBand" "final double lowerFrequency;"
  "AndroidEqualizerBand" "final double upperFrequency;"
  "AndroidEqualizerBand" "final double centerFrequency;"
  "AndroidEqualizerBand" "final _gainSubject = BehaviorSubject<double>();"
  "AndroidEqualizerBand" "AndroidEqualizerBand._({\n    required AudioPlayer player,\n    required this.index,\n    required this.lowerFrequency,\n    required this.upperFrequency,\n    required this.centerFrequency,\n    required double gain,\n  }) : _player = player {"
  "AndroidEqualizerParameters" "final double minDecibels;"
  "AndroidEqualizerParameters" "final double maxDecibels;"
  "AndroidEqualizerParameters" "final List<AndroidEqualizerBand> bands;"
  "AndroidEqualizerParameters" "AndroidEqualizerParameters({\n    required this.minDecibels,\n    required this.maxDecibels,\n    required this.bands,\n  });"
  "AndroidEqualizer" "AndroidEqualizerParameters? _parameters;"
  "AndroidEqualizer" "final Completer<AndroidEqualizerParameters> _parametersCompleter =
      Completer<AndroidEqualizerParameters>();"
)

# Perform the replacements
for replacement in "${replacements[@]}"; do
  target=$(echo "$replacement" | cut -d' ' -f1)
  value=$(echo "$replacement" | cut -d' ' -f2)
  sed -i "s/$target/$value/g" "$input_file"
done

# Print success message
echo "Replacements completed successfully."
